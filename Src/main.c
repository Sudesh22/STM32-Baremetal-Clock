/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f1xx.h"
#include "stdbool.h"
#include "main.h"
#include "stdio.h"
#include "stdlib.h"
// Slave address (7-bit format, replace with the actual address of your slave device)
#define SLAVE_ADDR  0x27
#define BACKLIGHT_FLAG 0x08   // Backlight control bit
#define ENABLE_FLAG 0x04      // Enable pin control bit
#define RS_FLAG 0x01          // Register Select control bit
#define COMMAND_MODE 0x00     // RS = 0 (Command mode)
#define CLR_CMD 0x01
#define DATA_MODE RS_FLAG     // RS = 1 (Data mode)
#define DS3231_ADDR 0x68

#define SEC_CMD 0x00
#define MIN_CMD 0x01
#define HRS_CMD 0x02
#define DAY_CMD 0x03
#define DATE_CMD 0x04
#define MONTH_CMD 0x05
#define YEAR_CMD 0x06

bool backlight = 0;
unsigned char ADSwrite[6];
int16_t reading;
float voltage[4];
const float voltageConv = 6.114 / 32768.0;

uint8_t sec;
uint8_t min;
uint8_t hrs;
uint8_t day;
uint8_t date;
uint8_t month;
uint8_t year;

char daysOfTheWeek[7][12] = {"Sun", "Mon", "Tues", "Wedn", "Thu", "Fri", "Sat"};

void system_clk()
{
	//ENABLE HSE AND WAIT TILL IT BECOMES READY
	RCC->CR |= RCC_CR_HSEON;	//HSE @8MHZ
	while(!(RCC->CR & RCC_CR_HSERDY))
		;

	//CONFIGURE FLASH PREFETCH AND LATENCY SETTINGS
	FLASH->ACR |= FLASH_ACR_PRFTBE|FLASH_ACR_LATENCY_1;

	//CONFIGURE PLL AND BUSES (AHB,APB1,APB2)
	//PLL SOURCE: HERE HSE IS USED AS A SOURCE
	RCC->CFGR |= RCC_CFGR_PLLSRC;
	//HSE DIVIDER FOR PLL (IF HSE IS USED AS SOURCE FOR PLL)
	RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;	//INPUT TO PLL 8MHZ
	//PLL MULTIPLIER: HERE HSE OUTPUT IS MULTIPLIED WITH 4
	RCC->CFGR |= RCC_CFGR_PLLMULL4;	//OUTPUT TO PLL IS 32MHZ
	//BUS CLOCK CONFIGURE(APB1,APB2,AHB): NOT DIVIDING
	RCC->CFGR |= (RCC_CFGR_PPRE1_DIV1|RCC_CFGR_PPRE2_DIV1|RCC_CFGR_HPRE_DIV1);
	//ENABLE THE PLL
	RCC->CR |= RCC_CR_PLLON;
	//WAIT FOR PLL TO SET
	while(!(RCC->CR & RCC_CR_PLLRDY))
		;

	//ENABLE SYSTEMCLK AND WAIT
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL))
		;

	GPIO_Init();
	//CLOCK OUTPUT ON MCO PIN
	RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;
}

void timer_init(){
	//Start by making sure that the timer's 'counter' is off
	TIM2->CR1 &= ~(TIM_CR1_CEN);
	TIM2->SR &= ~(TIM_SR_UIF);

	//RESET THE TIMER2 BUS
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST);

	//ENABLE THE TIMER2 PERIPHERAL CLOCK
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;


	/**********Eg1************/
	//Timer Prescaler value
	TIM2->PSC = 31;

	//Timer Auto Reload Register Value
	TIM2->ARR = 0xffff;

	//ENABLE THE UPDATE GENERATION
	TIM2->EGR |= TIM_EGR_UG;

	TIM2->CR1 |=TIM_CR1_CEN;
//	while(!(TIM2->SR & (1<<TIM_SR_UIF)));
}

void I2C1_Init(void) {
    // Enable I2C1 clock
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    // Reset I2C1
    RCC->APB1RSTR |= RCC_APB1RSTR_I2C1RST;
    RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;

    // Configure I2C_CR2 for peripheral input clock (FREQ = 36 MHz for STM32F103, this is the default)
    I2C1->CR2 = 0x24;  // FREQ = 36 MHz

    // Configure I2C_CCR for standard mode (100 kHz clock)
    I2C1->CCR = 0x28;  // 100 kHz clock

    // Configure I2C_TRISE for maximum rise time
    I2C1->TRISE = 0x09;  // TRISE = 9 for 36 MHz clock

    // Enable I2C peripheral
    I2C1->CR1 |= I2C_CR1_PE;
}

void I2C1_Writea(uint8_t addr, uint8_t data, uint8_t length) {
	// Wait until I2C is not busy
	    while (I2C1->SR2 & I2C_SR2_BUSY);

	    // Send start condition
	    I2C1->CR1 |= I2C_CR1_START;

	    // Wait for start bit generation
	    while (!(I2C1->SR1 & I2C_SR1_SB));

	    // Send slave address with write bit (addr << 1 | 0)
	    I2C1->DR = (addr << 1);

	    // Wait for address acknowledgment
	    while (!(I2C1->SR1 & I2C_SR1_ADDR));
	    (void)I2C1->SR2;  // Clear ADDR flag by reading SR2

	    // Send data
	    if (backlight == 1)
	    {
	    	data |= BACKLIGHT_FLAG;
	    }
	    I2C1->DR = data;

	    // Wait for byte transfer complete
	    while (!(I2C1->SR1 & I2C_SR1_BTF));

	    // Send stop condition
	    I2C1->CR1 |= I2C_CR1_STOP;
}

void I2C1_Write(uint8_t addr, uint8_t data, uint8_t length) {
    // Wait until I2C is not busy
    while (I2C1->SR2 & I2C_SR2_BUSY);

    // Send start condition
    I2C1->CR1 |= I2C_CR1_START;

    // Wait for start condition
    while (!(I2C1->SR1 & I2C_SR1_SB));

    // Send slave address with write bit (addr << 1)
    I2C1->DR = (addr << 1);

    // Wait for address acknowledgement
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;  // Clear the ADDR flag by reading SR2

    // Send the data bytes
//    for (uint8_t i = 0; i < length; i++) {
        I2C1->DR = data;
        while (!(I2C1->SR1 & I2C_SR1_BTF));  // Wait for byte transfer to finish
//    }

    // Send stop condition
    I2C1->CR1 |= I2C_CR1_STOP;
}

void I2C1_Read(uint8_t addr, uint8_t *data, uint8_t length) {
    // Wait until I2C is not busy
    while (I2C1->SR2 & I2C_SR2_BUSY);

    // Send start condition
    I2C1->CR1 |= I2C_CR1_START;

    // Wait for start condition
    while (!(I2C1->SR1 & I2C_SR1_SB));

    // Send slave address with read bit (addr << 1 | 1)
    I2C1->DR = (addr << 1) | 1;

    // Wait for address acknowledgment
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;  // Clear the ADDR flag by reading SR2

    // Read the data bytes
    for (uint8_t i = 0; i < length; i++) {
        while (!(I2C1->SR1 & I2C_SR1_RXNE));  // Wait for data to be received
        data[i] = I2C1->DR;
    }

    // Send stop condition
    I2C1->CR1 |= I2C_CR1_STOP;
}

void delay_us(uint16_t us) {
    uint16_t start = TIM2->CNT; // Capture the current counter value
    while ((TIM2->CNT - start) < us); // Wait until the elapsed time matches 'us'
}

void delay_ms(uint16_t ms){
	for (uint16_t i=0; i<ms; i++)
		delay_us(1000);
}

void GPIO_Init(void) {
    // Enable GPIOB clock
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

    // Configure PB6 (I2C1_SCL) and PB7 (I2C1_SDA) as alternate function open-drain
    GPIOB->CRL &= ~((GPIO_CRL_MODE6 | GPIO_CRL_MODE7) | (GPIO_CRL_CNF6 | GPIO_CRL_CNF7));  // Clear CNF and MODE bits
    GPIOB->CRL |= (GPIO_CRL_MODE6_1 | GPIO_CRL_MODE7_1) | (GPIO_CRL_CNF6_1 | GPIO_CRL_CNF7_1);  // Set to AF open-drain
}

void enableBacklight(){
	backlight = 1;
	I2C1_Writea(SLAVE_ADDR, BACKLIGHT_FLAG,1);
}

void setCursor(uint8_t column, uint8_t row){
//	static const uint8_t ROW_OFFSETS[] = {0x80, 0xC0};
	if (row==0){
		sendByteToLCD(0x80 | column, COMMAND_MODE);
	}
	else{
		sendByteToLCD(0xC0 | column, COMMAND_MODE);
	}
}

// Function to send an LCD command
void sendCommand(uint8_t command){
    sendByteToLCD(command, COMMAND_MODE);
}

void lcdInit(){
	delay_ms(50);
	send4BitData(0x30, COMMAND_MODE);  // Initialize to 8-bit mode
	delay_ms(5);
	send4BitData(0x30, COMMAND_MODE);  // Repeat initialization
	delay_ms(5);
	send4BitData(0x30, COMMAND_MODE);  // Ensure initialization
	delay_ms(5);
	send4BitData(0x20, COMMAND_MODE);  // Switch to 4-bit mode

	sendCommand(0x28);  // Function set: 4-bit mode, 2-line display, 5x8 dots
	sendCommand(0x0C);  // Display ON, cursor OFF
	sendCommand(0x06);  // Entry mode: Increment cursor, no shift
	sendCommand(0x01);  // Clear display
	delay_ms(2);           // Wait for clearing to complete

}

// Function to toggle the Enable pin to latch data
void pulseEnable(uint8_t data) {
    I2C1_Writea(SLAVE_ADDR, data | ENABLE_FLAG,1);   // Enable HIGH
    I2C1_Writea(SLAVE_ADDR, data & ~ENABLE_FLAG,1);  // Enable LOW
}

// Function to send 4-bit data to the LCD
void send4BitData(uint8_t data, uint8_t mode){
	uint8_t control;
	if (backlight == 1)
	{
		control = mode | BACKLIGHT_FLAG;
	}
	else{
		control = mode;
	}
    I2C1_Writea(SLAVE_ADDR, data | control,1);  // Send data
    pulseEnable(data | control);
}

// Function to send a full byte of data to the LCD (split into high and low nibbles)
void sendByteToLCD(uint8_t byte, uint8_t mode){
    send4BitData(byte & 0xF0, mode);         // Send high nibble
    send4BitData((byte << 4) & 0xF0, mode);  // Send low nibble
}

// Function to send data (characters) to the LCD
void sendData(uint8_t data) {
    sendByteToLCD(data, DATA_MODE);
}

void LCDPrintString(char *string){
	for (int i = 0; string[i] != '\0'; i++) {
		sendData((uint8_t)string[i]);
	}
}

// Function to display a BCD number on an LCD
void displayBCDOnLCD(uint8_t c, uint8_t r, uint8_t number) {
    uint8_t decimal = number; // Convert BCD to decimal

    char buffer[5]; // Buffer to hold the string representation (max 3 digits + null terminator)
    snprintf(buffer, sizeof(buffer), "%02d", decimal); // Convert decimal to string

    setCursor(c, r);        // Set cursor to the desired position (row 0, column 0)
    LCDPrintString(buffer);          // Display the converted decimal value
}


// Convert normal decimal numbers to binary coded decimal
uint8_t decToBcd(int val)
{
  return (uint8_t)( (val/10*16) + (val%10) );
}

// Function to convert BCD to Decimal
uint8_t bcdToDec(uint8_t bcd) {
    return ((bcd >> 4) * 10) + (bcd & 0x0F);
}

uint8_t getSeconds(){
	uint8_t seconds;
	I2C1_Write(DS3231_ADDR, SEC_CMD, 1);

	I2C1_Read(DS3231_ADDR, &seconds, 1);
	return bcdToDec(seconds);
}

uint8_t getMinutes() {
    uint8_t minutes;

    // Request the Minutes register (0x01)
    I2C1_Write(DS3231_ADDR, MIN_CMD, 1);  // Send register address (0x01)

    // Read the value from the Minutes register
    I2C1_Read(DS3231_ADDR, &minutes, 1);  // Read the minute data

    // Convert BCD to decimal
    return bcdToDec(minutes);
}

uint8_t getHours() {
    uint8_t hours;
    // Write to the DS3231 to set the register pointer to 0x02 (Hours register)
    I2C1_Write(DS3231_ADDR, HRS_CMD, 1);

    // Read 1 byte from the DS3231 (Hours register)
    I2C1_Read(DS3231_ADDR, &hours, 1);

    // Convert BCD to decimal and return
    return bcdToDec(hours);
}

uint8_t getDay() {
    uint8_t day;
    // Write to the DS3231 to set the register pointer to 0x02 (Hours register)
    I2C1_Write(DS3231_ADDR, DAY_CMD, 1);

    // Read 1 byte from the DS3231 (Hours register)
    I2C1_Read(DS3231_ADDR, &day, 1);

    // Convert BCD to decimal and return
    return bcdToDec(day);
}

uint8_t getDate() {
    uint8_t date;
    // Write to the DS3231 to set the register pointer to 0x02 (Hours register)
    I2C1_Write(DS3231_ADDR, DATE_CMD, 1);

    // Read 1 byte from the DS3231 (Hours register)
    I2C1_Read(DS3231_ADDR, &date, 1);

    // Convert BCD to decimal and return
    return bcdToDec(date);
}

uint8_t getMonth() {
    uint8_t month;
    // Write to the DS3231 to set the register pointer to 0x02 (Hours register)
    I2C1_Write(DS3231_ADDR, MONTH_CMD, 1);

    // Read 1 byte from the DS3231 (Hours register)
    I2C1_Read(DS3231_ADDR, &month, 1);

    // Convert BCD to decimal and return
    return bcdToDec(month);
}

uint8_t getYear() {
    uint8_t year;
    // Write to the DS3231 to set the register pointer to 0x02 (Hours register)
    I2C1_Write(DS3231_ADDR, YEAR_CMD, 1);

    // Read 1 byte from the DS3231 (Hours register)
    I2C1_Read(DS3231_ADDR, &year, 1);

    // Convert BCD to decimal and return
    return bcdToDec(year);
}

int main(void) {
	system_clk();
	timer_init();
    I2C1_Init();    // Initialize I2C1 peripheral
	enableBacklight();
	lcdInit();

    while (1) {
    	sec = getSeconds();
    	min = getMinutes();
    	hrs = getHours();
    	day = getDay();
    	date = getDate();
    	month = getMonth();
    	year = getYear();

    	setCursor(0, 0);
		LCDPrintString("Dt:");
		displayBCDOnLCD(3,0,date);

		LCDPrintString("/");
		displayBCDOnLCD(6,0,month);

		LCDPrintString("/");
		displayBCDOnLCD(9,0,year);

		setCursor(13, 0);
		LCDPrintString(daysOfTheWeek[day]);

		setCursor(0, 1);
		LCDPrintString("Time:");
		displayBCDOnLCD(6,1,hrs);

		setCursor(8, 1);
		LCDPrintString(":");
		displayBCDOnLCD(9,1,min);

		setCursor(11, 1);
		LCDPrintString(":");
		displayBCDOnLCD(12,1,sec);

    	delay_ms(1000);
    }
}

